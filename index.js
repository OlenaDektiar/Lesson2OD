'number' + 23 + 32; // 'number2332'- якщо  хочаб один з операндiв -string то оператор + виконую конкатенацiю  а не арифметичну дiю
41 + 1 + 'number'; // '42number'- обчислення злiва на право, далi число+рядок=рядок, конкатенацiя
null + 1; // 1, бо в математичних операціях null стає 0
'five' + + 'two'; // оператор ++ збільшує значення змінної на 1, але в даному випадку  видасть помилку, бо приклад не має числових значень
2 && 7; // 7, бо  обидва операнди не дорівнюють 0, а оператор && видає  другий операнд
+'40' + +'2'; // 42, робимо числове перетворення за допомогою number value
'10' - 5 === 6; // false, бо використовується оператор строго дорівнює, який враховує типи даних
true + false; // true (1), бо в булевій логіці  true відповідає числу 1, а false- 0
'4px' - 3; // NaN, бо перетворення за допомогою Number є суворим,  а значення '4px'  не є гарантованим числом
'4' - 3; // 1, бо то буде звичайна арифметична операція, для якої може бути використаний parseInt
'2' + 3 ** 2; // '29', бо бінарна операція ** значить 3 в квадраті, а отже 9, і потім, так як перший операнд-строка-все перетворюється в string
23 + 42 + 'number'; // '65number' обчислення злiва на право, далi число+рядок=рядок, конкатенацiя
12 / '6'; //  2, бо 6-явне число, і воно стає number за допомогою виклику number(value)
'10' + (5 === 6); //'10false', бо спочатку ми виконуємо строгу рівність 5 === 6, результатом якої буде false, а вже потімм відбувається конкатенація, і результат становится string
'number' + 15 + 3; // 'number153'якщо  хочаб один з операндiв -string то оператор + виконую конкатенацiю  а не арифметичну дiю
undefined + 1; // NaN, бо undefined в арифметичних операціях перетворюється в NaN, всі арифметичні операції з NaN в результаті дають NaN
'true' == true; // true, бо використовуэться оператор не строгого =
false == 'false'; // true, бо використовується оператор не строго =, а значить не враховується вид змінної
null == ''; // false, в даному випадку ''-пуста строка, яка не пертворюється в булеве значення і залишається string
3 ** (9 / 3); // 27 , бо 9/3=3, а 3 в 3 ступені = 27
!!'false' == !!'true'; // true, бо ! перетворює false в true,  а наступний ! перетворює true в false 
0 || '0' && 1;// 1 бо спочатку виконуєм логічний оператор І, де '0'- істинне значення і 1 також істинне значення, і повертається останній істинний операнд. Тобто 1. далі виконуємо оператор або. Він повертає перший істинний операнд
1 < 2 < 3; // true, бо виконуємо зліва направо. 1<2 і це true, далі порівнюєм true<3, i це також true, бо true стає 1
'foo'+ + +'bar'; // 'foobar' , бо  'bar' буде  не зважаючи на унарні +, і треба об'єднати 'foo'і NaN
3 ** 2 / 3; // 2, бо 3 в квадраті буде 9, і 9 ділимо  на 3
1 < 2 > 3; // false , бо 1<2 буде   true, true перетвориться на 1, а 1>3 буде хибним рівнянням
(+null == false) < 1; // false , бо дія в дужках буде true, так як null стає числом 0 і це дорівнює false, а так як true = 1, то рівняння 1<1 буде хибним
false && true || true; //  true, бо оператор І повертає true  якщо обидва операнди є правддивими, в нашому випадку це не так, і повертається  false, оператор або повертає перше правдиве значення, або останнє, якщо правдиве не було знайдено. 
false && (true || true); // false, бо  оператор або повертає перше правдиве значення, тобто у нас true, а оператор і дає false, коли один із операндів є False
(+null == false) < 1 ** 5; // false , бо 0=0 буде  true, а 1 в 5 ступені буде 1, значить true<1 або  1<1  видає хибне значення false